---
title: "msImpute: Imputation of peptide intensity by low-rank approximation"
author: 
- name: Soroor Hediyeh-zadeh
  affiliation: &id The Walter and Eliza Hall Institute of Medical Research
- name: Andrew I. Webb
  affiliation: *id
- name: Melissa J. Davis
  affiliation: *id
package: msImpute
abstract: |
  MsImpute is a package for imputation of peptide intensity in proteomics experiments. It additionally contains tools for MAR/MNAR diagnosis and assessment of distortions to the probability distribution of the data post imputation. This document covers case studies featuring data obtained by various Mass Spectrometry (MS) acquisition modes to demonstrate applications of tools implemented in the package. The datasets selected here represent data with MAR and left-censored MNAR missingness patterns. We demonstrate msImpute is able to correctly identify these patterns and inform user's decisions in downstream analyses.
output: 
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::pdf_document: default
vignette: >
  %\VignetteIndexEntry{msImpute: proteomics missing values imputation and diagnosis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---




_Since the proteomics quantification data (tables) are typically too large to be fully incorporated into R packages, the analyses presented are based on pre-processed data. The complete peptide and/or evidence tables for datasets used in this vignette can be downloaded from ProteomXchange repository. Alternatively, they can be downloaded from [GitHub](https://github.com/soroorh/proteomicscasestudies) as `rds` objects. Peptide and protein annotations are not included in the data attached to the package, as msImpute does not require this information. Please see the User's Guide for details of pre-processing steps._

# Installation


```{r eval=FALSE}
if(!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("msImpute")
```


# Quick Start

The package consists of the following main functions:

- `selectFeatures`: identifies peptides with high biological dropout rate. These peptides have a high abundance and high dropout. Their missingness pattern is used as a diagnostic for MAR/MNAR missingness type, which can then inform later decisions around imputation of the data.

- `scaleData`: _msImpute_ first scales the data before training a low-rank model

- `msImpute`: Main function that imputes missing values by learning a low-rank approximation of the data

- `findVariableFeatures`: finds peptide with high biological variance. We use this in `computeStructuralMetrics()`

- `computeStructuralMetrics`: returns a number of metrics that measure distortions into the data after imputation.


These functions overall are designed to inform user's decision on adopting an imputation strategy. 


# TIMS Case Study: Blood plasma 

The aim is to assess the missing patterns in ion mobility data by Prianichnikov et al. (2020), available from PXD014777. The `evidence` table of MaxQuant output was processed as described below. Rows are Modified Peptide IDs. Charge state variations are treated as distinct peptide species. For peptides with multiple identification types, the intensity is considered to be the median of reported intensity values. Reverse complements and contaminant peptides are discarded. Peptides with more than 4 observed intensity values are retained. 

The data was acquired in two batches (over two days). We are interested to know if missing values are evenly distributed across batches, or there is a batch-specific dropout trend. The runs are also labeled by S1, S2 and S4 (source unknown). The aim is to use this information to work out if missing values occur due to technical or biological effects.  


```{r setup, message=FALSE}
library(msImpute)
library(limma)
library(imputeLCMD)
library(ComplexHeatmap)
```

## Data processing

The following procedures were applied to process the data, which we later load from the package data.

### Filter by detection


```{r}
data(pxd014777)
y <- pxd014777
```


Zero values that will be converted to Inf/-Inf after log- transformation. Check if there are valid values in the data before log transformation
```{r}
table(is.infinite(data.matrix(log2(y))))
```

There are zero values that will be converted to Inf/-Inf after log- transformation. Add a small offset to avoid infinite values:
```{r}
y <- log2(y+0.25)
```

### Normalization
```{r}
# quantile normalisation
y <- normalizeBetweenArrays(y, method = "quantile")
```

## Determine missing values pattern

Determine dominant patterns of missing values by investigating the dropout pattern of high dropout peptides. We find top 500 peptides with higher than expected dropout rat and high average log-intensity, then make a heatmap of their dropout pattern.
```{r fig.align="center"}
hdp <- selectFeatures(y, n_features = 500)


# construct matrix M to capture missing entries
M <- ifelse(is.na(y),1,0)
M <- M[hdp$msImpute_feature,]

# plot a heatmap of missingness patterns for the selected peptides


batch <- as.factor(gsub("(2018.*)_RF.*","\\1", colnames(y)))
experiment <- as.factor(gsub(".*(S[1-9]).*","\\1", colnames(y)))
```

```{r fig.cap="Heatmap of missing value patterns for top 500 high dropout peptides", fig.align="center"}
ha_column <- HeatmapAnnotation(batch = batch,
                               experiment = experiment,
                               col = list(batch = c('20181023' = "#B24745FF",
                                                    '20181024'= "#00A1D5FF"),
                                          experiment=c("S1"="#DF8F44FF",
                                                       "S2"="#374E55FF",
                                                       "S4"="#79AF97FF")))

hm <- Heatmap(M,
column_title = "dropout pattern, columns ordered by dropout similarity",
              name = "Intensity",
              col = c("#8FBC8F", "#FFEFDB"),
              show_row_names = FALSE,
              show_column_names = FALSE,
              cluster_rows = TRUE,
              cluster_columns = TRUE,
              show_column_dend = FALSE,
              show_row_dend = FALSE,
              top_annotation = ha_column,
              row_names_gp =  gpar(fontsize = 7),
              column_names_gp = gpar(fontsize = 8),
              heatmap_legend_param = list(#direction = "horizontal",
              heatmap_legend_side = "bottom",
              labels = c("observed","missing"),
              legend_width = unit(6, "cm")),
         )
hm <- draw(hm, heatmap_legend_side = "left")
```
As it can be seen on the heatmap, missing values are evenly distributed over batches (there is no systematic clustering of samples by batch), however, samples labeled as `S2`in the file name tend to cluster together. It turns out that samples from `S1` and `S4` experiments are blood plasma from individuals, whereas samples labeled as `S2` are labeled as pooled plasma. This is a biological effect, and we just demonstrated that `msImpute` can detect biologically meaningful and informative results.  


# DDA Case Study: Extracellular vesicles isolated from inflammatory bowel disease patients and controls

The study aims to characterize the proteomic profile of extracellular vesicles isolated from the descending colon of pediatric patients with inflammatory bowel disease and control participants. The following analysis is based on the `peptide` table from MaxQuant output, available from PXD007959. Rows are Modified Peptide IDs. Charge state variations are treated as distinct peptide species. Reverse complements and contaminant peptides are discarded. Peptides with more than 4 observed intensity values are retained. Additionally, qualified peptides are required to map uniquely to proteins. Two of the samples with missing group annotation were excluded.

## Filter by detection


The sample descriptions can be accessed via `pxd007959$samples`. Intensity values are stored in `pxd007959$y`.
```{r}
data(pxd007959)

sample_annot <- pxd007959$samples
y <- pxd007959$y
y <- log2(y)
```

## Normalization
We apply `cyclic loess` normalisation from `limma` to normalise log-intensities. We have justified use of `cyclic loess` method in depth in the user's guide.
```{r}
y <- normalizeBetweenArrays(y, method = "cyclicloess")
```


## Determine missing values pattern

```{r fig.align="center"}
# determine missing values pattern
hdp <- selectFeatures(y, n_features = 500)
```



```{r fig.cap="Dropout pattern of top 500 high dropout peptides", fig.align="center"}
# construct matrix M to capture missing entries
M <- ifelse(is.na(y),1,0)
M <- M[hdp$msImpute_feature,]



# plot a heatmap of missingness patterns for the selected peptides
ha_column <- HeatmapAnnotation(group = as.factor(sample_annot$group),
                               col=list(group=c('Control' = "#E64B35FF",
                                                'Mild' = "#3C5488FF",
                                                'Moderate' = "#00A087FF",
                                                'Severe'="#F39B7FFF")))

hm <- Heatmap(M,
column_title = "dropout pattern, columns ordered by dropout similarity",
              name = "Intensity",
              col = c("#8FBC8F", "#FFEFDB"),
              show_row_names = FALSE,
              show_column_names = FALSE,
              cluster_rows = TRUE,
              cluster_columns = TRUE,
              show_column_dend = FALSE,
              show_row_dend = FALSE,
              top_annotation = ha_column,
              row_names_gp =  gpar(fontsize = 7),
              column_names_gp = gpar(fontsize = 8),
              heatmap_legend_param = list(#direction = "horizontal",
              heatmap_legend_side = "bottom",
              labels = c("observed","missing"),
              legend_width = unit(6, "cm")),
         )
hm <- draw(hm, heatmap_legend_side = "left")
```
As it can be seen, samples from the control group cluster together. There is a structured, block-wise pattern of missing values (i.e. missing values occur in all samples from control individuals, but are measured in disease group). This suggests that missing in not at random. This is an example of **MNAR** dataset. Given this knowledge, we impute using `QRILC` and `msImpute`. We then compare these methods by preservation of local (within experimental group) and global (between experimental group) similarities.

## Imputation
```{r}
# imputation

y_qrilc <- impute.QRILC(y)[[1]]

y_msImpute <- scaleData(y)
y_msImpute <- msImpute(y_msImpute)


group <- as.factor(sample_annot$group)

```

## Assessment of preservation of local and global structures 

If you've installed python, and have set up a python environment in your session, you can run this section to compute the GW distance. Here we have just included the results returned by `computeStructuralMetrics()` as text, as this may not run on all systems, if the python environment is not setup beforehand. Please see the user's guide for setup instructions. Note that you can still run `computeStructuralMetrics()`by setting `y=NULL`, if there are no python environments setup.

**Withinness, betweenness and Gromov-Wasserstein (GW) distance**

`computeStructuralMerics` returns three metrics that can be used to compare various imputation procedures:

- `withinness` is the sum of the squared distances between samples from the same experimental group (e.g. control, treatment, Het, WT). More specifically the similarity of the samples is measured by the distance of the  (expression profile of the) sample from group centroid. This is a measure of preservation of local structures.

- `betweenness` is the sum of the squared distances between the experimental groups, more specifically the distance between group centroids. This is a measure of preservation of global structures.

- `gw_dist` is the Gromov-Wasserstein distance computed between Principal Components of imputed and source data. It is a measure of how well the structures are overall preserved over all principal axis of variation in the data. Hence, it captures preservation of both local and global structures. PCs of the source data are computed using highly variable peptides (i.e. peptides with high biological variance).

An ideal imputation method results in smaller `withinness`, larger `withinness` and smaller `gw_dist` among other imputation methods.

```{r eval=FALSE}
top.hvp <- findVariableFeatures(y)

computeStructuralMetrics(y_msImpute, group, y[rownames(top.hvp)[1:50],], k = 16)
```

```{}
Computing GW distance using k= 16 Principal Components
$withinness
    Mild  Control Moderate   Severe 
8.615751 9.455355 8.692705 8.586565 

$betweenness
[1] 9.358183

$gw_dist
[1] 0.04294529
```


```{r eval=FALSE}
computeStructuralMetrics(y_qrilc, group, y[rownames(top.hvp)[1:50],], k = 16)
```

```{}
$withinness
    Mild  Control Moderate   Severe 
10.32911 11.83523 10.61441 10.76315 

$betweenness
[1] 11.61141

$gw_dist
[1] 0.008813667
```

`Withinness` is smaller by `msImpute`, which indicates that local structures are better preserved by these two methods. However, the `gw_dist` is smaller for `QRILC` over all PCs. This suggests that `QRILC` is likely a better approach compared to the other two methods. Given that the dominant patterns of missing values in this dataset is MNAR, `QRILC` is indeed a reasonable choice, as missing values are likely to be left-censored MNAR. Note that `k` is set to the number of samples to capture all dimensions of the data.




# SWATH-DIA Case Study: SWATH-MS analysis of Gfi1-mutant bone marrow neutrophils

This study investigates the proteomic alterations in bone marrow neutrophils isolated from 5-8 week old Gfi1+/-, Gfi1K403R/-, Gfi1R412X/-, and Gfi1R412X/R412X mice using the SWATH-MS technique. This dataset consists of 13 DIA (for SWATH) runs on a TripleTOF 5600 plus (SCIEX). Data available from PXD010943. Peak areas extracted from `13DIAs_SWATHprocessing_area_score_FDR_observedRT.xlsx`.^[Accessible via ProteomXchange]

Rows are peptides. Charge state variations are treated as distinct peptide species. Peptides with more than 4 observed intensity values are retained. 

### Normalization

We normalize using `quantile normalization`.
```{r}
data(pxd010943)
y <- pxd010943
# no problematic values for log- transformation
table(is.infinite(data.matrix(log2(y))))

y <- log2(y)
y <- normalizeBetweenArrays(y, method = "quantile")
```

## Determine missing values pattern

We use top 100 high dropout peptides as there are 180 partially observed peptides overall
```{r fig.align="center"}
hdp <- selectFeatures(y, n_features = 100) 
```


```{r fig.cap="Dropout pattern of top 100 high dropout peptides", fig.align="center"}

# construct matrix M to capture missing entries
M <- ifelse(is.na(y),1,0)
M <- M[hdp$msImpute_feature,]

# plot a heatmap of missingness patterns for the selected peptides

group <- as.factor(gsub("_[1234]", "", colnames(y)))

group

ha_column <- HeatmapAnnotation(group = group)

hm <- Heatmap(M,
column_title = "dropout pattern, columns ordered by dropout similarity",
              name = "Intensity",
              col = c("#8FBC8F", "#FFEFDB"),
              show_row_names = FALSE,
              show_column_names = FALSE,
              cluster_rows = TRUE,
              cluster_columns = TRUE,
              show_column_dend = FALSE,
              show_row_dend = FALSE,
              top_annotation = ha_column,
              row_names_gp =  gpar(fontsize = 7),
              column_names_gp = gpar(fontsize = 8),
              heatmap_legend_param = list(#direction = "horizontal",
              heatmap_legend_side = "bottom",
              labels = c("observed","missing"),
              legend_width = unit(6, "cm")),
         )
hm <- draw(hm, heatmap_legend_side = "left")
```
It can be seen that missing values are evenly distributed across the groups, and there is no systematic clustering of samples by experimental group. Hence, the dominant pattern of missingness is likely to be **MAR**.


We impute the data using a left-censored MNAR method (`QRILC`) and `msImpute` which is suitable for MAR dataets, then compare the two approaches.

## Imputation

```{r}
# imputation
y_qrilc <- impute.QRILC(y)[[1]]
```


Note that the scaling algorithm in `msImpute` does not converge at default iterations in this case. The number of iterations is increased to achieve convergence.
```{r}
y_msImpute <- scaleData(y, maxit = 50) # an example where iteration does not converge at default iteration number
y_msImpute <- msImpute(y_msImpute)
```

## Assessment of preservation of local and global structures

In this example, we do not compute `gw_dist` and only rely on `withinness` and `betweenness` metrics to assess imputation.
```{r}
top.hvp <- findVariableFeatures(y)

computeStructuralMetrics(y_msImpute, group, y=NULL)
```


```{r}
computeStructuralMetrics(y_qrilc, group, y = NULL)
```
Note `withinness` tend to be smaller in `msImpute`, while `betweenness` is marginally larger for `QRILC`. The differences in `betweenness` between `QRILC` and `msImpute` is small. Note that since such a small proportion of peptides are missing, and the dominant missingness pattern appear to be MAR, one can also choose to not impute depending on the downstream analyses.



# References

Prianichnikov, N., Koch, H., Koch, S., Lubeck, M., Heilig, R., Brehmer, S., Fischer, R., & Cox, J. (2020). MaxQuant Software for Ion Mobility Enhanced Shotgun Proteomics. Molecular & cellular proteomics : MCP, 19(6), 1058–1069. https://doi.org/10.1074/mcp.TIR119.001720

Zhang, X., Deeke, S.A., Ning, Z. et al. Metaproteomics reveals associations between microbiome and intestinal extracellular vesicle proteins in pediatric inflammatory bowel disease. Nat Commun 9, 2873 (2018). https://doi.org/10.1038/s41467-018-05357-4

Muench, D.E., Olsson, A., Ferchen, K. et al. Mouse models of neutropenia reveal progenitor-stage-specific defects. Nature 582, 109–114 (2020). https://doi.org/10.1038/s41586-020-2227-7 

# Session info {-}
```{r echo=FALSE}
sessionInfo()
```
